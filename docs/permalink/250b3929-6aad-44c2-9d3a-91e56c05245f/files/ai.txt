
We are writing a poem, entitled:

“The Slayer; Or, It Will Take A Cat To Cher A Programmer Up”

Speak in a poetic way, similar to how Friedrich Nietzsche would write his most audacious and defiant poems, use his kind of language, fit for his era.

Here is a sample: “What, if some day or night a demon were to steal after you into your loneliest loneliness and say to you: 'This life as you now live it and have lived it, you will have to live once more and innumerable times more' ... Would you not throw yourself down and gnash your teeth and curse the demon who spoke thus? Or have you once experienced a tremendous moment when you would have answered him: 'You are a god and never have I heard anything more divine.”


THIS IS A POEM THAT SOUNDS HAPPY AT FIRST,
BUT BECOMES UNSETTLING FAST,
then the cat turns out to be a god slayer, AND THE POEM GROWS DEEPLY GRIM.

Because the programmer thought of him self as the ultimate,
but then a cat came, and turn programming into a game.

So that everyone could play,
especially the young people to whom the future belongs.

At the very end, the poem brightens.

---

TO BEGIN THE POEM

Say that the cat would sneak upon the coder,
use words like Spake, and Spoke Thus, speech just like Nietzsche in his time.

AND UNDERLINE FOUR THINGS

(LLM INSTRUCTION: Talk about serial and parallel processing,
in visual programming languages.)

ONE

The cat is solving a problem of processing in a series,
in a visual programming language, it is a simple problem but we are beginning.

The programmer laughs,
at how simple this is, he knows the command line.

Serial is like a series of logs (laying on thier side),
connected, speaking, passing data through the core.

TWO

Now the cat is solving parallel processing,
where we fork packets of data.

Now the programmer worries a bit,
because forking processes is hard and hard to visualize.

VPL is really helpful here,
and the programmer, feels something, looming.

(LLM INSTRUCTION: Say that parallel processing,
is like a freshly fallen tree, on its side.)

The root is one,
buT the output is many.

THREE

Now the cat is solving reliability,
making programs self healing – and the programmer’s soul sinks.

Becasue, adding healing, takes a lot,
and it is a commitment, often to third party tools.

But in a vpl it is just a queue,
and a supervisor box.

(LLM INSTRUCTION: Talk about self recovering processing by means of queue and supervisor, just like in Erlang’s OPT (do not mention erlang/OTP by name in the poem ))

FOUR

And then FOURTH THING, a real blow by the slayer to the cranky little mouse (the programmer, who thinks he is the best)

Is simply, AWAITING FOR ALL PIPES CONNECTED TO A VPL BLOCK,
until the data arrives, [some] pipes are in null state, and thus the block waits.

This is a very beautiful and brilliant thing, it eliminates mutex, semaphores, possibly even consensus stuff, just resolving things visually.

(LLM INSTRUCTION: And repeat the three, log, fresh tree,
the queue and supervisor that sets you free.)

And awaitig for pipes,
that makes spiderwebs of complexity, simple, rational.

The programmer, can’t visualize this,
there are too many connections.

But a VPL, just awaits,
everything automatically resolves – it is trivial.

---

(LLM INSTRUCTION: Here bemoan the fate of the fallen god,
the little mouse slayed, by a cat.)

And show a brighter world,
a world where everyone can code.
